#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

class SessionBoundaryDetector {
    constructor() {
        this.activityLog = '.meta/ai-activity-log';
        this.stateFile = '.meta/session-state.json';
        this.loadState();
    }

    loadState() {
        try {
            if (fs.existsSync(this.stateFile)) {
                this.state = JSON.parse(fs.readFileSync(this.stateFile, 'utf8'));
            } else {
                this.state = {
                    lastProcessedLine: 0,
                    sessionActive: false,
                    sessionStartTime: null,
                    commandCount: 0
                };
            }
        } catch (error) {
            this.state = {
                lastProcessedLine: 0,
                sessionActive: false,
                sessionStartTime: null,
                commandCount: 0
            };
        }
    }

    saveState() {
        fs.writeFileSync(this.stateFile, JSON.stringify(this.state, null, 2));
    }

    checkBoundary() {
        if (!fs.existsSync(this.activityLog)) {
            return;
        }

        const activity = this.getNewActivity();
        if (activity.length === 0) {
            return;
        }

        // Process new activity
        for (const line of activity) {
            this.processActivityLine(line);
        }

        this.saveState();
    }

    getNewActivity() {
        const content = fs.readFileSync(this.activityLog, 'utf8');
        const lines = content.split('\n').filter(line => line.trim());
        
        const newLines = lines.slice(this.state.lastProcessedLine);
        this.state.lastProcessedLine = lines.length;
        
        return newLines;
    }

    processActivityLine(line) {
        if (line.includes('AI_RESPONSE_START') || line.includes('COMMAND_START')) {
            if (!this.state.sessionActive) {
                this.startSession();
            }
            this.state.commandCount++;
        }
        
        if (line.includes('AI_RESPONSE_END')) {
            this.endSession('explicit_end');
        }
        
        // Check for inactivity-based session end
        if (this.state.sessionActive && this.hasInactivity()) {
            this.endSession('inactivity');
        }
    }

    startSession() {
        this.state.sessionActive = true;
        this.state.sessionStartTime = Date.now();
        this.state.commandCount = 0;
        console.log('üïê AI Session started');
    }

    endSession(reason) {
        if (!this.state.sessionActive) {
            return;
        }

        console.log(`üèÅ AI Session ended (${reason}). Commands: ${this.state.commandCount}`);
        
        // Trigger hourglass capture
        this.triggerHourglass();
        
        this.state.sessionActive = false;
        this.state.sessionStartTime = null;
        this.state.commandCount = 0;
    }

    hasInactivity() {
        if (!this.state.sessionStartTime) {
            return false;
        }
        
        const inactivityThreshold = 5000; // 5 seconds
        return (Date.now() - this.state.sessionStartTime) > inactivityThreshold;
    }

    triggerHourglass() {
        try {
            // Capture any available AI response content
            this.captureAIResponseContent();
            
            // Trigger hourglass with complete session data
            const { spawn } = require('child_process');
            spawn('node', ['src/hourglass.js', 'trigger', 'activity-detected', 'session-complete'], {
                stdio: 'inherit',
                detached: false
            });
        } catch (error) {
            console.error('Failed to trigger hourglass:', error.message);
        }
    }
    
    captureAIResponseContent() {
        try {
            // Look for AI response content files
            const responseFiles = [
                '.meta/ai-response-complete.txt',
                '.meta/current-ai-response.txt',
                '.meta/ai-response-content.txt'
            ];
            
            let responseContent = '[AI_RESPONSE_CAPTURED_BY_ACTIVITY]';
            
            for (const file of responseFiles) {
                if (fs.existsSync(file)) {
                    responseContent = fs.readFileSync(file, 'utf8');
                    // Clean up after capture
                    fs.unlinkSync(file);
                    break;
                }
            }
            
            // Save to be picked up by hourglass
            fs.writeFileSync('.meta/session-response-content.txt', responseContent);
            console.log('üìù AI response content captured and prepared for hourglass');
            
        } catch (error) {
            console.error('Failed to capture AI response content:', error.message);
        }
    }
}

// Run if called directly
if (require.main === module) {
    const detector = new SessionBoundaryDetector();
    detector.checkBoundary();
}

module.exports = SessionBoundaryDetector;